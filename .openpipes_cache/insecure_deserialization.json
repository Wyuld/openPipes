{
  "title": "Insecure Deserialization",
  "cvssv3": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:L",
  "description": "Muitas vezes, é conveniente serializar objetos para comunicação ou salvá-los para uso posterior. No entanto, códigos ou dados desserializados podem frequentemente ser modificados sem o uso das funções de acesso fornecidas, caso não utilizem criptografia para se proteger. Além disso, qualquer criptografia ainda seria considerada segurança do lado do cliente, o que é uma suposição de segurança perigosa. Não se pode confiar que dados não confiáveis sejam bem formados. Quando os desenvolvedores não impõem restrições às &quot;cadeias de gadgets&quot;, ou seja, séries de instâncias e invocações de métodos que podem ser executadas automaticamente durante o processo de desserialização (ou seja, antes que o objeto seja retornado ao chamador), elas podem, às vezes, ser exploradas por invasores para realizar ações não autorizadas, como gerar um shell. Serialização e desserialização referem-se ao processo de pegar os dados relacionados ao objeto interno do programa, empacotando-os de uma forma que permita que os dados sejam armazenados ou transferidos externamente (&quot;serialização&quot;) e, então, extrair os dados serializados para reconstruir o objeto original (&quot;desserialização&quot;).",
  "observation": "Integridade: Estado inesperado: invasores podem modificar objetos ou dados inesperados que eram considerados seguros contra modificações. Disponibilidade: DoS: Consumo de recursos (CPU): Se uma função estiver fazendo uma suposição sobre quando terminar, com base em uma sentinela em uma sequência de caracteres, ela pode facilmente nunca terminar. Outros: Varia de acordo com o contexto: As consequências podem variar bastante, pois dependem de quais objetos ou métodos estão sendo desserializados e de como são usados. Presumir que o código no objeto desserializado é válido é perigoso e pode permitir exploração.",
  "remediation": "Possíveis mitigações para diferentes fases do processo de criação do aplicativo são descritas abaixo: Fases: Arquitetura e design; implementação. Se disponível, utilize os recursos de assinatura/selagem da linguagem de programação para garantir que os dados desserializados não tenham sido corrompidos. Por exemplo, um código de autenticação de mensagens baseado em hash (HMAC) pode ser usado para garantir que os dados não tenham sido modificados. Fase: Implementação. Ao desserializar dados, recomenda-se preencher um novo objeto em vez de apenas desserializar. O resultado é que os dados passam por uma validação de entrada segura e as funções são seguras. Fase: Implementação. Defina explicitamente um objeto final() para evitar a desserialização. Fases: Arquitetura e Design; Implementação. Torne os campos transitórios para protegê-los da desserialização. Uma tentativa de serializar e depois desserializar uma classe contendo campos transitórios resultará em NULLs onde os dados transitórios deveriam estar. Essa é uma ótima maneira de evitar que variáveis temporárias, de ambiente ou sensíveis sejam transferidas e usadas indevidamente. Fase: Implementação. Evite ter tipos ou gadgets desnecessários disponíveis que possam ser explorados para fins maliciosos. Isso limita a possibilidade de tipos e gadgets indesejados ou não autorizados serem explorados pelo invasor. Adicione apenas classes aceitáveis a uma lista de permissões. Observação: Novos gadgets são descobertos constantemente, portanto, isso por si só não é uma mitigação suficiente.",
  "references": [
    "https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/10-Business_Logic_Testing/01-Test_Business_Logic_Data_Validation",
    "https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html",
    "https://cwe.mitre.org/data/definitions/502.html"
  ]
}
